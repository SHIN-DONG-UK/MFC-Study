### 목차
-	MFC의 핵심 개념
-	MFC의 동작 흐름 요약
-	MFC와 Win32 비교

### [1] MFC의 핵심 개념
- MFC는 Win32 API를 객체 지향(C++)으로 감싸서 쉽게 쓸 수 있도록 만든 프레임워크

<br>

(1) 객체 지향 기반  
- 모든 윈도우, 대화상자, 컨트롤이 클래스와 객체로 표현

| Win32 API	| MFC 클래스|
|-|-|
|HWND	| CWnd |
|Dialog Box	|CDialog
|Button	|CButton

	- 예:

-	이 덕분에 상속, 다형성, 캡슐화 활용 가능

(2)	메시지 맵
-	Win32의 WindProc 메시지 처리를 MFC에서 클래스 기반으로 연결
-	기존 WndProc 의 switch-case를 대신해 메시지 -> 멤버 함수 매핑

```cpp
class CMyDialog : public CDialogEx
{
public:
    afx_msg void OnBnClickedMyButton();  // 버튼 클릭 이벤트 처리

    DECLARE_MESSAGE_MAP()  // 메시지 맵 선언
};

BEGIN_MESSAGE_MAP(CMyDialog, CDialogEx)
    ON_BN_CLICKED(IDC_MYBUTTON, &CMyDialog::OnBnClickedMyButton)
END_MESSAGE_MAP()
```
-핵심: Win 32 메시지 처리 -> MFC 메시지 맵으로 객체지향화

(3)	애플리케이션 클래스(CWinApp)
-	프로그램 전체를 대표하는 클래스
-	WinMain() 대신 “CWinApp를 상속받은 클래스의 InitInstance()”가 진입점
```cpp
class CMyApp : public CWinApp
{
public:
    virtual BOOL InitInstance();
};

CMyApp theApp;  // 전역 객체
```

(4)	리소스 기반 GUI
-	MFC는 리소스(.rc) 파일 + 클래스를 기반으로 GUI 생성
-	리소스 에디터에서 버튼, 에디트 박스 배치 -> ID 부여 -> 코드에서 C++ 객체와 연결


### [2] MFC 동작 흐름 요약
1. CWinApp 객체 생성 -> InitInstance() 호출
2. 메인 윈도우 또는 대화상자 생성
3. 메시지 루프 실행 -> GetMessage 기반
4. 메시지 맵을 통해 이벤트 처리
5. 종료 시 리소스 정리 및 소멸자 호출

> InitInstance() → Main Window/Dialog 생성 → 메시지 루프 → 이벤트 처리 → 종료

### [3] MFC와 Win32 비교
|구분	|Win32	|MFC|
|-|-|-|
|창	|HWND, 직접 API 호출	|CWnd, CDialog 등 객체|
|메시지|	WndProc + switch-case	|메시지 맵 → 멤버 함수|
|GUI 생성|	CreateWindow, MoveWindow 등|	리소스 + C++ 객체|
|이벤트 처리|	함수 포인터|	객체 멤버 함수 + 메시지 맵|
|코드량|	많음|	상대적으로 적음, 구조화 용이|








