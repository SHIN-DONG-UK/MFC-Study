### 목차
-	클래스와 객체
-	상속
-	다형성과 가상 함수

### [1] 클래스와 객체
- 클래스는 “설계도”이고, 객체는 그 설계도로 만든 “실체”
- 멤버 변수(데이터)와 멤버 함수(동작)을 묶어서 하나의 단위로 관리할 수 있게 함
- 캡슐화(encapsulation)의 핵심

```cpp
class Car {
private:
    int speed;         // 멤버 변수
public:
    void accelerate() { speed += 10; } // 멤버 함수
    void showSpeed() { cout << speed << endl; }
};
```

-	Private 멤버: 클래스 외부(상속한 자식 클래스도 포함)에서 직접 접근 불가(정보 은닉)
-	Public 멤버: 클래스 외부에서 접근 가능
-	생성자: 객체가 생성될 때 자동으로 호출
-	소멸자: 객체가 파괴될 때 자동 호출

> MFC와의 연관성  
MFC는 모든 기능을 클래스로 묶은 구조  
즉, 모든 것이 객체로 표현됨 


### [2] 상속
- 기존 클래스(부모 클래스)의 속성과 기능을 확장하거나 재사용하기 위한 개념
- class Derived : public Base 형태로 선언
```cpp
class Shape {
public:
    void draw() { cout << "Draw Shape" << endl; }
};

class Circle : public Shape {
public:
    void draw() { cout << "Draw Circle" << endl; } // 함수 재정의(오버라이딩)
};
```
-	코드 재사용이 용이
-	부모 클래스의 멤버를 자식 클래스에서 사용할 수 있음
-	자식 클래스에서 부모의 동작을 수정할 수 있음(함수 오버라이딩)

> MFC와의 연관성  
MFC의 거의 모든 클래스는 상속 구조로 되어 있음  
우리는 대부분 CDialog나 CView를 상속받아 사용할거임

### [3] 다형성과 가상 함수
- “같은 인터페이스로 다양한 객체를 다룰 수 있는 능력”
- 부모 클래스의 포인터로 자식 클래스의 객체를 제어할 수 있게 됨
- 이를 위해 가상 함수(virtual function)가 사용됨
```cpp
class Shape {
public:
    virtual void draw() { cout << "Draw Shape" << endl; }
};

class Circle : public Shape {
public:
    void draw() override { cout << "Draw Circle" << endl; }
};

int main() {
    Shape* s = new Circle();
    s->draw();  // "Draw Circle"
    delete s;
}
```

-	Virtual 키워드가 없으면 정적 바인딩(컴파일 시 결정)
-	Virtual이 있으면 동적 바인딩(실행 시 실제 객체 타입에 따라 결정)
-	소멸자도 가상 함수로 선언하는 것이 안전(virtual ~Shape())

> MFC와의 연관성  
MFC는 다형성의 대표적인 사례  
MFC는 가상 함수 기반 이벤트 처리 시스템으로 동작  


### [4] 포인터와 참조
- 포인터는 변수의 메모리 주소를 저장하는 변수
- 참조(reference)는 변수의 또 다른 이름(alias)
즉, 포인터는 대상의 주소를 저장하는 “변수”이고, 참조는 또 다른 이름일 뿐 대상과 동일
```cpp
int a = 10;
int* p = &a;     // p는 a의 주소를 가리킴
int& ref = a;    // ref는 a의 별명

*p = 20;         // a의 값도 20으로 변경됨
ref = 30;        // a의 값도 30으로 변경됨
```
-	함수 인자로 포인터를 넘기면 “call by reference” 효과
-	객체 지향 프로그래밍에서 동적 객체 관리에 필수

> MFC와의 연관성  
MFC는 거의 모든 객체를 포인터로 관리  
`CWnd* pWnd = AfxGetMainWnd();`  
`pWnd->ShowWindow(SW_SHOW);`  
GUI 요소는 실행 중에 생성되고 파괴되므로, 포인터 관리가 핵심


### [5] 동적 메모리 관리 (new/delete)
- 실행 중에 메모리를 할당받거나 해제하는 방식
- new로 생성하면 힙(heap) 영역에 메모리가 할당되고, 반드시 delete로 해제하여야 함

```cpp
int* p = new int;   // 동적 메모리 할당 (int 타입을 위한 메모리 주소 획득)
*p = 10;
delete p;           // 메모리 해제
```
-	new[] / delete[] -> 배열 할당/해제
-	메모리 누수(memory leak)에 주의
-	스마트 포인터로 대체 가능

>MFC와의 연관성  
MFC 내부에서는 new를 통해 윈도우, 대화상자, 컨트롤 등이 동적 생성됨

### [6] 템플릿(Template)과 STL(Standard Template Library)
- 템플릿은 자료형에 독립적인 코드 작성 방법
- STL은 템플릿 기반으로 구현된 표준 라이브러리
 (예: vector, list, map, string 등)
 ```cpp
template <typename T>
T add(T a, T b) { return a + b; }

int main() {
    cout << add(3, 4) << endl;       // int
    cout << add(1.2, 3.4) << endl;   // double
}
```
-	코드 재사용성 향상
-	STL 컨테이너를 통해 자료구조 직접 구현 없이 사용 가능

>MFC와의 연관성  
MFC는 자체적으로 CArray, CList, CMap같은 템플릿 기반 컬렉션 클래스를 제공  
STL과 병행 사용 가능  

### [7] 헤더(.h)와 소스(.cpp) 분리
- C++ 프로젝트는 보통 “선언과 정의의 분리” 원칙을 따름
- .h: 클래스나 함수의 선언
- .cpp: 선언된 것들의 실제 구현부
```cpp
// MyClass.h
#pragma once
class MyClass {
public:
    void sayHello();
};

// MyClass.cpp
#include "MyClass.h"
#include <iostream>
using namespace std;

void MyClass::sayHello() {
    cout << "Hello, World!" << endl;
}
```
-	#pragma once 또는 include guard로 중복 포함 방지
-	헤더는 선언만 포함해야 함
-	.cpp에서 실제 로직 구현

>MFC와의 연관성  
MFC 프로젝트 구조는 철저히 이 원칙을 따른다  
```MyDialog.h, MyDialog.cpp```  
```MyApp.h, MyApp.cpp```
