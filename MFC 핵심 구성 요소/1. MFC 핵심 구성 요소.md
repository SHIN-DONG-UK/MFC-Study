### 목차
- 애플리케이션 클래스
- 윈도우 클래스/윈도우 객체
- 메시지 맵
- 문서-뷰 구조
- 컨트롤 클래스
- 리소스
- 메시지 루프

### [1] 애플리케이션 클래스 (CWinApp)
- 역할: 프로그램 전체를 대표
- Win32 API의 WinMain() 역할을 대체
- 프로그램 시작 -> 초기화 -> 메시지 루프 -> 종료 관리
- 상속해서 구현

```cpp
class CMyApp : public CWinApp
{
public:
    virtual BOOL InitInstance();  // 초기화 코드 작성
};

CMyApp theApp;  // 전역 객체, WinMain 역할 수행
```

- `InitInstance()`에서 매번 윈도우 생성, 리소스 초기화, 대화상자 실행 등 수행
- `CWinApp::Run()`이 메시지 루프를 자동으로 처리

### [2] 윈도우 클래스/윈도우 객체(CWnd)
- Win32 API의 `HWND + WndProc`을 C++ 객체로 추상화
- 모든 창(Window)과 컨트롤(Btton, Edit, List 등)의 기본 클래스
- 상속으로 기능 확장 가능

```cpp
CWnd* pWnd = new CWnd();
pWnd->Create(...);  // 실제 창 생성
```
- 대표 파생 클래스
   - `CFrameWnd`: 기본 프레임 창
   - `CDialog`: 대화상자
   - `CView`: SDI/MDI에서 문서 표시 영역

### [3] 메시지 맵(Message Map)
- Win32 API의 `WndProc` 에서는 모든 메시지를 `switch-case`로 분기 처리
- MFC에서는 메시지와 멤버 함수를 연결하는 **정적 메시지 맵** 구조를 사용

```cpp
class CMyDialog : public CDialogEx
{
    afx_msg void OnBnClickedButton();  // 버튼 클릭 처리
    DECLARE_MESSAGE_MAP()
};

BEGIN_MESSAGE_MAP(CMyDialog, CDialogEx)
    ON_BN_CLICKED(IDC_MYBUTTON, &CMyDialog::OnBnClickedButton)
END_MESSAGE_MAP()
```

- MFC는 매크로를 통해 메시지와 멤버 함수를 연결하는 정적 테이블을 생성
- OS로부터 메시지가 전달되면, 메시지 맵을 조회해 해당 멤버 함수를 자동 호출
- 즉, Win32의 `WndProc` 구조를 객체지향적으로 확장한 형태


### [4] 문서-뷰 구조(Documnet/View)
- SDI/MDI 애플리케이션에서 사용
- 역할 분리
  - 문서(Document)
    - 애플리케이션의 **핵심 데이터**를 관리
    - 파일 입출력, 데이터 저장/복원 담당
    - `CDocument` 클래스를 기반으로 구현
  - 뷰(View)
    - 문서의 데이터에 **화면을 표시하고 사용자와 상호작용(UI)** 담당
    - `CView` 또는 `CFormView` 기반
- 장점
  - MVC(Model-View-Controller) 패턴과 유사한 구조로, 데이터와 화면의 관심사를 분리함
  - 하나의 문서에 여러 뷰를 연결할 수도 있어 동기화된 데이터 표시 가능
- 문서와 뷰 모두 C++ 객체이며, 프레임워크(MFC)가 문서-뷰 연결 및 메시지 전달을 자동으로 관리함

### [5] 컨트롤 클래스
- MFC에서는 **모든 GUI 컨트롤(버튼, 에디트 박스, 리스트 박스 등)이 C++ 객체**로 캡슐화되어 있음  
-> 예:
  - `CButton` (버튼)
  - `CEdit` (텍스트 입력창)
  - `CListBox`, `CComboBox`, `CStatic` 등
- 컨트롤 ID와 클래스 멤버 변수를 연결하여 코드에서 직접 접근 가능
- 메시지 맵(Message Map)을 통해 이벤트 처리  
  ->예: 버튼 클릭 시 `BN_CLIKED` 메시지를 `OnBnClickedMyButton()` 함수에 매핑
- 따라서,
  - 컨트롤 -> 운영체제 메시지 발생
  - MFC -> 메시지 맵을 통해 해당 멤버 함수 자동 호출
  - 개발자는 함수 안에서 로직만 작성하면 됨


>뷰와 컨트롤  
컨트롤은 결국 View 내부에서 정의되어야 한다  
그래야 OS가 View내의 컨트롤을 찾아 메시지를 보낸다  

### [6] 리소스(Resource)
- 리소스(.rc) 파일
  - UI 요소 및 기타 정적 데이터를 정의하는 파일
  - 예시
    - **대화상자(Dialog)** -> 폼, 버튼, 에디트 박스 등
    - **메뉴(Menu)** -> 메뉴바, 컨텍스트 메뉴
    - **아이콘(Icon), 비트맵(Bitmap), 문자열(String Table)** 등
- 코드와 연결
  - MFC에서 C++ 객체와 연결하여 동작하도록 함
  - 예시:
    - `CDialog` -> 대화상자 리소스
    - `CMenu` -> 메뉴 리소스
    - `CBitmap`, `CImageList` -> 비트맵 리소스
- 장점
  - UI와 로직을 **분리** -> 코드 유지보수와 수정 용이
  - 리소스 편집기에서 시각적으로 UI를 수정 가능
  - 여러 언어(다국어) 지원이나 아이콘/이미지 교체도 용이

### [7] 메시지 루프 (CWinApp::Run)
- **Win32 메시지 루프 기반**
  - Win32 API의 `GetMessage()` 흐름을 기반으로 함
  - OS가 발생시키는 메시지를 에플리케이션으로 전달

- **MFC의 역할**
  - MFC가 `CWinApp::Run()` 내부에서 메시지 루프를 자동으로 처리
  - 개발자는 직접 `GetMessage()` 루프를 작성할 필요 없음

- **메시지 전달 구조**
  1. OS -> 메시지 큐에 메시지 삽입
  2. `CWinApp::Run()` 내부 루프에서 메시지를 가져옴
  3. MFC가 **메시지 맵(Message Map)** 을 통해 적절한 **클래스 멤버 함수** 호출
     - 예: 버튼 클릭 -> `OnBnClickedButton()` 호출


